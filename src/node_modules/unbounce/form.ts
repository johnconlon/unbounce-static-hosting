import FauxFormData from "faux-form-data";

export type UnbounceForm = HTMLFormElement;

// Return a reference to the Unbounce form element.
// TODO: more robust
export function getForm() {
  return document.querySelector(".lp-pom-form form");
}

// Fill an Unbounce form with data from a FauxFormData object.
// For this to work, the form defined in Unbounce must have field names which exactly match the
// field names of the form data passed in by the application.
// For example, if the application has a form containing a "full_name" field and we want to fill
// an Unbounce form with the value of that field, the Unbounce form must also have a field with the
// name "full_name".
//
// Unbounce form fields should only be of types: text, radio, or hidden.
//
// NOTE:Doesn't work with radio, checkbox, or select inputs in the unbounce form. Use a hidden input for the
// radio instead. This is generally fince since the unbounce form is hidden anyway.
// That being said:
// TODO: support multiselect
export function fill(formData: FauxFormData, form: UnbounceForm) {
  formData.forEach((name: string, value: string[]) => {
    const field = form[name] as HTMLInputElement | RadioNodeList;

    if (!field) {
      throw new Error(`Cannot fill field ${name}. Field doesn't exist.`);
    }
    field.value = value[0];

    // If we're setting the value of a radio input and the value we're trying to set is
    // not one of the options in the radio group, the value won't change. Detect
    // that and throw an error so we can fix it.
    if (field.value !== value[0]) {
      throw new Error(
        `Value mismatch between dynamic form and unbounce form for field ${name} and value ${
          value[0]
        }`
      );
    }
  });
}

// Submit an unbounce form.
// Unbounce reacts to the submit event, so we have to manually dispatch one.
export function submit(form: UnbounceForm) {
  const event = document.createEvent('Event')
  event.initEvent('submit', true, true)
  form.dispatchEvent(event)
}
